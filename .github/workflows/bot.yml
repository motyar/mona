name: Telegram Bot

on:
  schedule:
    - cron: '* * * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: telegram-bot
  cancel-in-progress: true

jobs:
  bot:
    runs-on: ubuntu-latest
    timeout-minutes: 1
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      REPO: ${{ github.repository }}
    steps:
      - uses: actions/checkout@v4

      - name: Run bot
        run: |
          node --input-type=module << 'EOF'
          import { readFile, writeFile } from 'fs/promises';

          const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
          const OPENAI_KEY = process.env.OPENAI_API_KEY;
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const REPO = process.env.REPO;
          const STATE_FILE = 'memory/state.json';
          const MAX_HISTORY = 20;

          const ghHeaders = {
            'Authorization': `Bearer ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28',
            'Content-Type': 'application/json'
          };

          async function loadState() {
            try {
              const raw = await readFile(STATE_FILE, 'utf8');
              return JSON.parse(raw);
            } catch {
              return { offset: 0, conversations: {} };
            }
          }

          async function saveState(state) {
            await writeFile(STATE_FILE, JSON.stringify(state, null, 2) + '\n');
          }

          async function telegramGetUpdates(offset) {
            const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/getUpdates?offset=${offset}&timeout=0&limit=10`;
            const res = await fetch(url);
            const data = await res.json();
            return data.ok ? data.result : [];
          }

          async function telegramSend(chatId, text) {
            const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
            await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ chat_id: chatId, text, parse_mode: 'Markdown' })
            });
          }

          async function callOpenAI(messages) {
            const systemPrompt = `You are a helpful assistant embedded in a Telegram bot. You have access to a GitHub repository and can help manage it.

          When responding, you MUST always reply with a valid JSON object (no markdown, no code blocks, raw JSON only) in this exact shape:

          {
            "intent": "<one of: chat | create_issue | create_pr | assign_copilot_issue | assign_copilot_pr | list_issues | list_prs>",
            "reply": "<the message to send back to the user on Telegram>",
            "data": {
              "title": "...",
              "body": "...",
              "issue_number": 123,
              "pr_number": 123,
              "head_branch": "...",
              "base_branch": "main"
            }
          }

          Intent definitions:
          - chat: normal conversation, no GitHub action needed
          - create_issue: user wants to create a new GitHub issue (optionally assign to Copilot)
          - create_pr: user wants to create a new pull request (optionally assign to Copilot)
          - assign_copilot_issue: user wants to assign an existing issue to @copilot
          - assign_copilot_pr: user wants to assign an existing PR to @copilot for review
          - list_issues: user wants to see open issues
          - list_prs: user wants to see open pull requests

          For create_issue and create_pr, check if the user mentions "copilot", "assign to copilot", or "let copilot handle it" — if so, set data.assign_copilot = true.

          The reply field must always contain a friendly human-readable response confirming what you did or answering the question.

          The repository context is: ${REPO}`;

            const res = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${OPENAI_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: [{ role: 'system', content: systemPrompt }, ...messages]
              })
            });
            const data = await res.json();
            if (!data.choices || !data.choices.length) {
              throw new Error(`OpenAI API error: ${JSON.stringify(data)}`);
            }
            return data.choices[0].message.content;
          }

          async function handleGitHubAction(intent, data) {
            const base = 'https://api.github.com';
            try {
              if (intent === 'create_issue') {
                const res = await fetch(`${base}/repos/${REPO}/issues`, {
                  method: 'POST',
                  headers: ghHeaders,
                  body: JSON.stringify({
                    title: data.title,
                    body: data.body || '',
                    assignees: data.assign_copilot ? ['copilot'] : []
                  })
                });
                const issue = await res.json();
                if (!res.ok) return `GitHub API error: ${res.status} ${JSON.stringify(issue)}`;
                return `✅ Created issue #${issue.number}: ${issue.title} — ${issue.html_url}${data.assign_copilot ? ' and assigned to @copilot!' : ''}`;
              }

              if (intent === 'create_pr') {
                const res = await fetch(`${base}/repos/${REPO}/pulls`, {
                  method: 'POST',
                  headers: ghHeaders,
                  body: JSON.stringify({
                    title: data.title,
                    body: data.body || '',
                    head: data.head_branch,
                    base: data.base_branch || 'main'
                  })
                });
                const pr = await res.json();
                if (!res.ok) return `GitHub API error: ${res.status} ${JSON.stringify(pr)}`;
                if (data.assign_copilot) {
                  await fetch(`${base}/repos/${REPO}/pulls/${pr.number}/requested_reviewers`, {
                    method: 'POST',
                    headers: ghHeaders,
                    body: JSON.stringify({ reviewers: ['copilot'] })
                  });
                }
                return `✅ Created PR #${pr.number}: ${pr.title} — ${pr.html_url}${data.assign_copilot ? ' and requested review from @copilot!' : ''}`;
              }

              if (intent === 'assign_copilot_issue') {
                const res = await fetch(`${base}/repos/${REPO}/issues/${data.issue_number}`, {
                  method: 'PATCH',
                  headers: ghHeaders,
                  body: JSON.stringify({ assignees: ['copilot'] })
                });
                if (!res.ok) {
                  const err = await res.json();
                  return `GitHub API error: ${res.status} ${JSON.stringify(err)}`;
                }
                return `✅ Assigned @copilot to issue #${data.issue_number}`;
              }

              if (intent === 'assign_copilot_pr') {
                const res = await fetch(`${base}/repos/${REPO}/pulls/${data.pr_number}/requested_reviewers`, {
                  method: 'POST',
                  headers: ghHeaders,
                  body: JSON.stringify({ reviewers: ['copilot'] })
                });
                if (!res.ok) {
                  const err = await res.json();
                  return `GitHub API error: ${res.status} ${JSON.stringify(err)}`;
                }
                return `✅ Requested review from @copilot on PR #${data.pr_number}`;
              }

              if (intent === 'list_issues') {
                const res = await fetch(`${base}/repos/${REPO}/issues?state=open&per_page=5`, {
                  headers: ghHeaders
                });
                const issues = await res.json();
                if (!res.ok) return `GitHub API error: ${res.status} ${JSON.stringify(issues)}`;
                if (issues.length === 0) return 'No open issues found.';
                return issues.map(i => `• #${i.number} ${i.title}\n  ${i.html_url}`).join('\n');
              }

              if (intent === 'list_prs') {
                const res = await fetch(`${base}/repos/${REPO}/pulls?state=open&per_page=5`, {
                  headers: ghHeaders
                });
                const prs = await res.json();
                if (!res.ok) return `GitHub API error: ${res.status} ${JSON.stringify(prs)}`;
                if (prs.length === 0) return 'No open pull requests found.';
                return prs.map(p => `• #${p.number} ${p.title}\n  ${p.html_url}`).join('\n');
              }
            } catch (err) {
              return `Error calling GitHub API: ${err.message}`;
            }
            return null;
          }

          // --- Main ---
          let currentChatId = null;
          try {
            const state = await loadState();
            const updates = await telegramGetUpdates(state.offset);

            if (!updates || updates.length === 0) {
              console.log('No new updates.');
              process.exit(0);
            }

            for (const update of updates) {
              try {
                if (!update.message || !update.message.text) {
                  state.offset = update.update_id + 1;
                  continue;
                }

                const chatId = update.message.chat.id;
                currentChatId = chatId;
                const userText = update.message.text;
                state.offset = update.update_id + 1;

                if (!state.conversations[chatId]) {
                  state.conversations[chatId] = [];
                }

                state.conversations[chatId].push({ role: 'user', content: userText });

                const rawResponse = await callOpenAI(state.conversations[chatId]);

                let intent = 'chat';
                let reply = rawResponse;
                let data = {};

                try {
                  const parsed = JSON.parse(rawResponse);
                  intent = parsed.intent || 'chat';
                  reply = parsed.reply || rawResponse;
                  data = parsed.data || {};
                } catch {
                  // Treat as plain chat reply
                }

                if (intent !== 'chat') {
                  const actionResult = await handleGitHubAction(intent, data);
                  if (actionResult) reply = actionResult;
                }

                await telegramSend(chatId, reply);

                state.conversations[chatId].push({ role: 'assistant', content: reply });
                state.conversations[chatId] = state.conversations[chatId].slice(-MAX_HISTORY);
              } catch (err) {
                console.error(`Error processing update ${update.update_id}:`, err);
                if (currentChatId) {
                  try {
                    await telegramSend(currentChatId, `❌ Sorry, something went wrong: ${err.message}`);
                  } catch {}
                }
              }
            }

            await saveState(state);
          } catch (err) {
            console.error('Fatal error:', err);
            if (currentChatId) {
              try {
                await telegramSend(currentChatId, `❌ Bot error: ${err.message}`);
              } catch {}
            }
            process.exit(1);
          }
          EOF

      - name: Commit state
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main
          git add memory/state.json
          git diff --cached --quiet || git commit -m "chore: update bot state [skip ci]"
          git push
