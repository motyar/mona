name: Telegram Bot

on:
  schedule:
   workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: telegram-bot
  cancel-in-progress: true

jobs:
  bot:
    runs-on: ubuntu-latest
    timeout-minutes: 1
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      REPO: ${{ github.repository }}
    steps:
      - uses: actions/checkout@v4

      - name: Run bot
        run: |
          node --input-type=module << 'EOF'
          import { readFile, writeFile } from 'fs/promises';

          // --- Constants ---
          const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
          const OPENAI_KEY = process.env.OPENAI_API_KEY;
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const REPO = process.env.REPO;
          const STATE_FILE = 'memory/state.json';
          const MAX_HISTORY = 20;

          // --- Helper: githubCall ---
          async function githubCall(method, path, body = null) {
            const res = await fetch(`https://api.github.com${path}`, {
              method,
              headers: {
                'Authorization': `Bearer ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28',
                'Content-Type': 'application/json'
              },
              body: body ? JSON.stringify(body) : undefined
            });
            const json = await res.json();
            if (!res.ok) throw new Error(`GitHub API error: ${res.status} ${JSON.stringify(json)}`);
            return json;
          }

          // --- Helper: telegramSend ---
          async function telegramSend(chatId, text) {
            const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
            await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ chat_id: chatId, text, parse_mode: 'Markdown' })
            });
          }

          // --- Skill Registry ---
          const SKILLS = [
            {
              intent: 'chat',
              description: 'General conversation. Use when no GitHub action is needed.',
              dataFields: null,
              execute: async (data, context) => {
                return data.reply;
              }
            },
            {
              intent: 'create_issue',
              description: 'Create a new GitHub issue in the repository.',
              dataFields: {
                title: 'string - the issue title',
                body: 'string - the issue body or description',
                assign_copilot: 'boolean - true if user wants copilot to handle it'
              },
              execute: async (data, context) => {
                const issue = await context.github('POST', `/repos/${context.env.REPO}/issues`, {
                  title: data.title,
                  body: data.body || '',
                  assignees: data.assign_copilot ? ['copilot'] : []
                });
                return `✅ Created issue #${issue.number}: ${issue.title} — ${issue.html_url}${data.assign_copilot ? ' and assigned to @copilot!' : ''}`;
              }
            },
            {
              intent: 'create_pr',
              description: 'Create a new pull request in the repository.',
              dataFields: {
                title: 'string - the PR title',
                body: 'string - the PR body or description',
                head_branch: 'string - the source branch name',
                base_branch: 'string - the target branch name (default: main)',
                assign_copilot: 'boolean - true if user wants copilot to review'
              },
              execute: async (data, context) => {
                const pr = await context.github('POST', `/repos/${context.env.REPO}/pulls`, {
                  title: data.title,
                  body: data.body || '',
                  head: data.head_branch,
                  base: data.base_branch || 'main'
                });
                if (data.assign_copilot) {
                  await context.github('POST', `/repos/${context.env.REPO}/pulls/${pr.number}/requested_reviewers`, {
                    reviewers: ['copilot']
                  });
                }
                return `✅ Created PR #${pr.number}: ${pr.title} — ${pr.html_url}${data.assign_copilot ? ' and requested review from @copilot!' : ''}`;
              }
            },
            {
              intent: 'assign_copilot_issue',
              description: 'Assign an existing issue to @copilot to implement.',
              dataFields: {
                issue_number: 'number - the issue number to assign'
              },
              execute: async (data, context) => {
                await context.github('PATCH', `/repos/${context.env.REPO}/issues/${data.issue_number}`, {
                  assignees: ['copilot']
                });
                return `✅ Assigned @copilot to issue #${data.issue_number}`;
              }
            },
            {
              intent: 'assign_copilot_pr',
              description: 'Request @copilot to review an existing pull request.',
              dataFields: {
                pr_number: 'number - the pull request number'
              },
              execute: async (data, context) => {
                await context.github('POST', `/repos/${context.env.REPO}/pulls/${data.pr_number}/requested_reviewers`, {
                  reviewers: ['copilot']
                });
                return `✅ Requested review from @copilot on PR #${data.pr_number}`;
              }
            },
            {
              intent: 'list_issues',
              description: 'List open issues in the repository.',
              dataFields: null,
              execute: async (data, context) => {
                const issues = await context.github('GET', `/repos/${context.env.REPO}/issues?state=open&per_page=5`);
                if (issues.length === 0) return 'No open issues found.';
                return issues.map(i => `• #${i.number} ${i.title}\n  ${i.html_url}`).join('\n');
              }
            },
            {
              intent: 'list_prs',
              description: 'List open pull requests in the repository.',
              dataFields: null,
              execute: async (data, context) => {
                const prs = await context.github('GET', `/repos/${context.env.REPO}/pulls?state=open&per_page=5`);
                if (prs.length === 0) return 'No open pull requests found.';
                return prs.map(p => `• #${p.number} ${p.title}\n  ${p.html_url}`).join('\n');
              }
            }
          ];

          // --- Helper: buildSystemPrompt ---
          function buildSystemPrompt() {
            const intentList = SKILLS.map(skill => {
              const fields = skill.dataFields
                ? '\n' + Object.entries(skill.dataFields)
                    .map(([k, v]) => `      - ${k}: ${v}`)
                    .join('\n')
                : '';
              return `- ${skill.intent}: ${skill.description}${fields}`;
            }).join('\n');

            return `You are a helpful assistant embedded in a Telegram bot connected to a GitHub repository.

          When responding, you MUST always reply with a valid JSON object — raw JSON only, no markdown, no code blocks.

          Response shape:
          {
            "intent": "<intent string>",
            "reply": "<friendly human-readable message to send to the user>",
            "data": { <fields relevant to the intent> }
          }

          Available intents:
          ${intentList}

          For any intent involving GitHub actions, always populate the relevant data fields.
          For the "chat" intent, only the "reply" field matters.
          If the user mentions "copilot", "assign to copilot", or "let copilot handle it", set assign_copilot: true in data.

          Repository: ${REPO}`;
          }

          // --- Helper: callOpenAI ---
          async function callOpenAI(messages) {
            const systemPrompt = buildSystemPrompt();
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${OPENAI_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: [{ role: 'system', content: systemPrompt }, ...messages]
              })
            });
            const data = await res.json();
            if (!data.choices || !data.choices.length) {
              throw new Error(`OpenAI API error: ${JSON.stringify(data)}`);
            }
            return data.choices[0].message.content;
          }

          // --- Helper: route ---
          async function route(intent, data, context) {
            const skill = SKILLS.find(s => s.intent === intent);
            if (!skill) {
              return data.reply || "I'm not sure how to help with that.";
            }
            try {
              return await skill.execute(data, context);
            } catch (err) {
              console.error(`Error in skill "${intent}":`, err);
              return `⚠️ Something went wrong: ${err.message}`;
            }
          }

          // --- State helpers ---
          async function loadState() {
            try {
              const raw = await readFile(STATE_FILE, 'utf8');
              return JSON.parse(raw);
            } catch {
              return { offset: 0, conversations: {} };
            }
          }

          async function saveState(state) {
            await writeFile(STATE_FILE, JSON.stringify(state, null, 2) + '\n');
          }

          async function telegramGetUpdates(offset) {
            const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/getUpdates?offset=${offset}&timeout=0&limit=10`;
            const res = await fetch(url);
            const data = await res.json();
            return data.ok ? data.result : [];
          }

          // --- Main ---
          let currentChatId = null;
          try {
            const state = await loadState();
            const updates = await telegramGetUpdates(state.offset);

            if (!updates || updates.length === 0) {
              console.log('No new updates.');
              process.exit(0);
            }

            const context = {
              chatId: null,
              github: githubCall,
              telegram: telegramSend,
              env: { REPO, GITHUB_TOKEN, TELEGRAM_TOKEN, OPENAI_KEY }
            };

            for (const update of updates) {
              try {
                if (!update.message || !update.message.text) {
                  state.offset = update.update_id + 1;
                  continue;
                }

                const chatId = update.message.chat.id;
                currentChatId = chatId;
                context.chatId = chatId;
                const userText = update.message.text;
                state.offset = update.update_id + 1;

                if (!state.conversations[chatId]) {
                  state.conversations[chatId] = [];
                }

                state.conversations[chatId].push({ role: 'user', content: userText });

                const rawResponse = await callOpenAI(state.conversations[chatId]);

                let intent = 'chat';
                let reply = rawResponse;
                let data = {};

                try {
                  const parsed = JSON.parse(rawResponse);
                  intent = parsed.intent || 'chat';
                  reply = parsed.reply || rawResponse;
                  data = parsed.data || {};
                } catch {
                  // Treat as plain chat reply
                }

                data.reply = reply;
                const result = await route(intent, data, context);
                if (result) reply = result;

                await telegramSend(chatId, reply);

                state.conversations[chatId].push({ role: 'assistant', content: reply });
                state.conversations[chatId] = state.conversations[chatId].slice(-MAX_HISTORY);
              } catch (err) {
                console.error(`Error processing update ${update.update_id}:`, err);
                if (currentChatId) {
                  try {
                    await telegramSend(currentChatId, `❌ Sorry, something went wrong: ${err.message}`);
                  } catch {}
                }
              }
            }

            await saveState(state);
          } catch (err) {
            console.error('Fatal error:', err);
            if (currentChatId) {
              try {
                await telegramSend(currentChatId, `❌ Bot error: ${err.message}`);
              } catch {}
            }
            process.exit(1);
          }
          EOF

      - name: Commit state
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add memory/state.json
          git diff --cached --quiet || git commit -m "chore: update bot state [skip ci]"
          git pull --rebase origin main
          git push
